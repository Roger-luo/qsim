import numpy as np
import networkx as nx
from qsim.codes import qubit, rydberg
from qsim.codes.quantum_state import State
from qsim import tools
# TODO: never use expm!
from scipy.linalg import expm
import scipy.sparse as sparse
from scipy.sparse.linalg import expm_multiply
from qsim.graph_algorithms.graph import Graph, IS_projector


class HamiltonianDriver(object):
    def __init__(self, transition: tuple = (0, 1), energies=None, pauli='X', code=None, IS_subspace=False, graph=None):
        """Default is that the first element in transition is the higher energy s."""
        if energies is None:
            energies = [1]
        self.transition = transition
        self.energies = energies
        self.pauli = pauli
        if code is None:
            code = qubit
        self.code = code
        if self.pauli == 'X' and not self.code.logical_code:
            self._operator = np.zeros((self.code.d, self.code.d))
            self._operator[self.transition[1], self.transition[0]] = 1
            self._operator[self.transition[0], self.transition[1]] = 1
        elif self.pauli == 'Y' and not self.code.logical_code:
            self._operator = np.zeros((self.code.d, self.code.d))
            self._operator[self.transition[1], self.transition[0]] = 1j
            self._operator[self.transition[0], self.transition[1]] = -1j
        elif self.pauli == 'Z' and not self.code.logical_code:
            self._operator = np.zeros((self.code.d, self.code.d))
            self._operator[self.transition[0], self.transition[0]] = 1
            self._operator[self.transition[1], self.transition[1]] = -1
        elif self.pauli == 'X' and self.code.logical_code:
            self._operator = self.code.X
        elif self.pauli == 'Y' and self.code.logical_code:
            self._operator = self.code.Y
        elif self.pauli == 'Z' and self.code.logical_code:
            self._operator = self.code.Z
        self.IS_subspace = IS_subspace
        if self.IS_subspace:
            # Generate sparse mixing Hamiltonian
            assert graph is not None
            assert isinstance(graph, Graph)
            if code is not qubit:
                IS, nary_to_index, num_IS = graph.independent_sets_code(self.code)
            else:
                # We have already solved for this information
                IS, nary_to_index, num_IS = graph.independent_sets, graph.binary_to_index, graph.num_independent_sets
            if self.pauli == 'Z':
                self._diagonal_hamiltonian = np.zeros((num_IS, 1))
                for k in IS:
                    self._diagonal_hamiltonian[k, 0] = np.sum(IS[k][2] == self.transition[0]) - np.sum(
                        IS[k][2] == self.transition[1])
                self._diagonal_hamiltonian = self._diagonal_hamiltonian
                self._hamiltonian = sparse.csr_matrix(
                    (self._diagonal_hamiltonian.T[0], (np.arange(len(self._diagonal_hamiltonian)),
                                                       np.arange(len(self._diagonal_hamiltonian)))))

            elif self.pauli == 'X' or self.pauli == 'Y':
                # For each IS, look at spin flips generated by the laser
                # Over-allocate space
                rows = np.zeros(graph.n * num_IS, dtype=int)
                columns = np.zeros(graph.n * num_IS, dtype=int)
                entries = np.zeros(graph.n * num_IS, dtype=float)
                num_terms = 0
                for i in IS:
                    for j in range(len(IS[i][2])):
                        if IS[i][2][j] == self.transition[1]:
                            # Flip spin at this location
                            # Get binary representation
                            temp = IS[i][2].copy()
                            temp[j] = self.transition[0]
                            flipped_temp = tools.nary_to_int(temp, base=code.d)
                            if flipped_temp in nary_to_index:
                                # This is a valid spin flip
                                rows[num_terms] = nary_to_index[flipped_temp]
                                columns[num_terms] = i
                                if self.pauli == 'X':
                                    entries[num_terms] = 1
                                elif self.pauli == 'Y':
                                    entries[num_terms] = -1j
                                num_terms += 1
                # Cut off the excess in the arrays
                columns = columns[:2 * num_terms]
                rows = rows[:2 * num_terms]
                entries = entries[:2 * num_terms]
                # Populate the second half of the entries according to self.pauli
                if self.pauli == 'X':
                    columns[num_terms:2 * num_terms] = rows[:num_terms]
                    rows[num_terms:2 * num_terms] = columns[:num_terms]
                    entries[num_terms:2 * num_terms] = entries[:num_terms]
                elif self.pauli == 'Y':
                    columns[num_terms:2 * num_terms] = rows[:num_terms]
                    rows[num_terms:2 * num_terms] = columns[:num_terms]
                    entries[num_terms:2 * num_terms] = -1 * entries[:num_terms]
                # Now, construct the Hamiltonian
                self._hamiltonian = sparse.csr_matrix((entries, (rows, columns)), shape=(num_IS, num_IS))
            # TODO: define self.hamiltonian for non-IS_subspace
            self._left_acting_hamiltonian = None
            self._right_acting_hamiltonian = None

    @property
    def hamiltonian(self):
        return self.energies[0] * self._hamiltonian

    @property
    def evolution_operator(self, vector_space='hilbert'):
        if vector_space != 'hilbert' and vector_space != 'liouville':
            raise Exception('Attribute vector_space must be hilbert or liouville')
        if vector_space == 'liouville':
            if self._left_acting_hamiltonian is None:
                self._left_acting_hamiltonian = sparse.kron(sparse.identity(self._hamiltonian.shape[0]),
                                                            self._hamiltonian)
                self._right_acting_hamiltonian = sparse.kron(self._hamiltonian.T,
                                                             sparse.identity(self._hamiltonian.shape[0]))

            return -1j * self.energies[0] * self._left_acting_hamiltonian + 1j * self.energies[0] * \
                   self._right_acting_hamiltonian
        else:
            return -1j * self.hamiltonian

    def left_multiply(self, state: State):
        if not self.IS_subspace:
            temp = np.zeros_like(state)
            # For each logical qubit
            state_shape = state.shape
            for i in range(state.number_logical_qudits):
                if self.code.logical_code:
                    if self.pauli == 'X':
                        temp = temp + self.code.left_multiply(state, [i], ['X'])
                    elif self.pauli == 'Y':
                        temp = temp + self.code.left_multiply(state, [i], ['Y'])
                    elif self.pauli == 'Z':
                        temp = temp + self.code.left_multiply(state, [i], ['Z'])
                elif not self.code.logical_code:
                    ind = self.code.d ** i
                    out = np.zeros_like(state, dtype=np.complex128)
                    if state.is_ket:
                        state = state.reshape((-1, self.code.d, ind), order='F')
                        # Note index start from the right (sN,...,s3,s2,s1)
                        out = out.reshape((-1, self.code.d, ind), order='F')
                        if self.pauli == 'X':  # Sigma_X
                            # We want to exchange two indices
                            out[:, [self.transition[0], self.transition[1]], :] = \
                                state[:, [self.transition[1], self.transition[0]], :]
                        elif self.pauli == 'Y':  # Sigma_Y
                            out[:, [self.transition[0], self.transition[1]], :] = \
                                state[:, [self.transition[1], self.transition[0]], :]
                            out[:, self.transition[0], :] = -1j * out[:, self.transition[0], :]
                            out[:, self.transition[1], :] = 1j * out[:, self.transition[1], :]
                        elif self.pauli == 'Z':  # Sigma_Z
                            out[:, [self.transition[0], self.transition[1]], :] = \
                                state[:, [self.transition[0], self.transition[1]], :]
                            out[:, self.transition[1], :] = -1 * out[:, self.transition[1], :]
                        state = state.reshape(state_shape, order='F')
                        out = out.reshape(state_shape, order='F')
                    else:
                        out = out.reshape((-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1),
                                           self.code.d, ind), order='F')
                        state = state.reshape((-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1),
                                               self.code.d, ind), order='F')

                        if self.pauli == 'X':  # Sigma_X
                            out[:, [self.transition[0], self.transition[1]], :, :, :] = \
                                state[:, [self.transition[1], self.transition[0]], :, :, :]
                        elif self.pauli == 'Y':  # Sigma_Y
                            out[:, [self.transition[0], self.transition[1]], :, :, :] = \
                                state[:, [self.transition[1], self.transition[0]], :, :, :]
                            out[:, self.transition[0], :, :, :] = -1j * out[:, self.transition[0], :, :, :]
                            out[:, self.transition[1], :, :, :] = 1j * out[:, self.transition[1], :, :, :]
                        elif self.pauli == 'Z':  # Sigma_Z
                            out[:, [self.transition[0], self.transition[1]], :, :, :] = \
                                state[:, [self.transition[0], self.transition[1]], :, :, :]
                            out[:, self.transition[1], :, :, :] = -1 * out[:, self.transition[1], :, :, :]
                        state = state.reshape(state_shape, order='F')
                        out = out.reshape(state_shape, order='F')
                    temp = temp + out
            return State(self.energies[0] * temp, is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code)
        else:
            # Handle dimensions
            if self.pauli == 'Z' and not self.code.logical_code:  # In this case, the Hamiltonian is diagonal
                return State(self.hamiltonian * state, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace,
                             code=state.code)
            else:
                return State(self.hamiltonian @ state, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace,
                             code=state.code)

    def right_multiply(self, state: State):
        assert not state.is_ket, 'Right multiply functionality currently only exists for density matrices.'
        if not self.IS_subspace:
            temp = np.zeros_like(state)
            # For each physical qubit
            state_shape = state.shape
            for i in range(state.number_logical_qudits):
                if self.code.logical_code:
                    if self.pauli == 'X':
                        temp = temp + self.code.right_multiply(state, [i], ['X'])
                    elif self.pauli == 'Y':
                        temp = temp + self.code.right_multiply(state, [i], ['Y'])
                    elif self.pauli == 'Z':
                        temp = temp + self.code.right_multiply(state, [i], ['Z'])
                elif not self.code.logical_code:
                    ind = self.code.d ** i
                    out = np.zeros_like(state)
                    out = out.reshape(
                        (-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1), self.code.d, ind),
                        order='F')
                    state = state.reshape(
                        (-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1), self.code.d, ind),
                        order='F')
                    if self.pauli == 'X' and not self.code.logical_code:  # Sigma_X
                        out[:, :, :, [self.transition[0], self.transition[1]], :] = state[:, :, :, [self.transition[1],
                                                                                                    self.transition[0]],
                                                                                    :]
                    elif self.pauli == 'Y' and not self.code.logical_code:  # Sigma_Y
                        out[:, :, :, [self.transition[0], self.transition[1]], :] = state[:, :, :, [self.transition[1],
                                                                                                    self.transition[0]],
                                                                                    :]
                        out[:, :, :, self.transition[0], :] = -1j * out[:, :, :, self.transition[0], :]
                        out[:, :, :, self.transition[1], :] = 1j * out[:, :, :, self.transition[1], :]
                    elif self.pauli == 'Z' and not self.code.logical_code:  # Sigma_Z
                        out[:, :, :, [self.transition[0], self.transition[1]], :] = state[:, :, :, [self.transition[0],
                                                                                                    self.transition[1]],
                                                                                    :]
                        out[:, :, :, self.transition[1], :] = -1 * state[:, :, :, self.transition[1], :]
                        state = state.reshape(state_shape, order='F')
                    state = state.reshape(state_shape, order='F')
                    out = out.reshape(state_shape, order='F')
                    temp = temp + out
            return State(self.energies[0] * temp, is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code)
        else:
            return State(state * self.hamiltonian.T, is_ket=state.is_ket, IS_subspace=state.IS_subspace,
                         code=state.code)

    def evolve(self, state: State, time):
        r"""
        Use reshape to efficiently implement evolution under :math:`H_B=\\sum_i X_i`
        """
        if not self.IS_subspace:
            # We don't want to modify the original s
            out = state.copy()
            for i in range(state.number_logical_qudits):
                # Note that self._operator is not necessarily involutary
                if self.pauli == 'X':
                    out = self.code.rotation(out, [i], self.energies[0] * time, self._operator)
                elif self.pauli == 'Y':
                    out = self.code.rotation(out, [i], self.energies[0] * time, self._operator)
                elif self.pauli == 'Z':
                    out = self.code.rotation(out, [i], self.energies[0] * time, self._operator)
            return out
        else:
            # Handle dimensions
            if self.hamiltonian.shape[1] == 1:
                return State(np.exp(-1j * time * self.hamiltonian) * state, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)
            else:
                return State(expm_multiply(-1j * time * self.hamiltonian, state),
                             is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code)


class HamiltonianMaxCut(object):
    def __init__(self, G: Graph, code=None, energies=None):
        # If MIS is true, create an MIS Hamiltonian. Otherwise, make a MaxCut Hamiltonian
        r"""
        Generate a vector corresponding to the diagonal of the MaxCut Hamiltonian.
        """
        if energies is None:
            energies = [1]
        if code is None:
            self.code = qubit
        else:
            self.code = code
        self.energies = energies
        # Make sure all edges have weight attribute; default to 1

        self.graph = G
        self.optimization = 'max'
        self.N = self.graph.n
        c = np.zeros([self.code.d ** (self.code.n * self.N), 1])
        if tools.is_diagonal(self.code.Z):
            self._is_diagonal = True
            z = np.expand_dims(np.diagonal(self.code.Z), axis=0).T

            def my_eye(n):
                return np.ones((np.asarray(self.code.d ** self.code.n) ** n, 1))
        else:
            self._is_diagonal = False
            # Compute the optimum first. We don't care that this takes extra time, since it only needs to run once
            z = np.expand_dims(np.diagonal(qubit.Z), axis=0).T

            def my_eye(n):
                return np.ones((np.asarray(qubit.d ** qubit.n) ** n, 1))

            for a, b in self.graph.edges:
                if b < a:
                    a, b = b, a
                c = c - 1 / 2 * G.graph[a][b]['weight'] * (tools.tensor_product(
                    [my_eye(a), z, my_eye(b - a - 1), z, my_eye(self.N - b - 1)]) - my_eye(self.N))
            self._optimum = np.max(c).real
            c = np.zeros([self.code.d ** (self.code.n * self.N), 1])

            z = self.code.Z

            def my_eye(n):
                return np.identity(np.asarray(z.shape[0]) ** n)

        for a, b in self.graph.edges:
            if b < a:
                a, b = b, a
            c = c - 1 / 2 * G.graph[a][b]['weight'] * (tools.tensor_product(
                [my_eye(a), z, my_eye(b - a - 1), z, my_eye(self.N - b - 1)]) - my_eye(self.N))
        if self._is_diagonal:
            self._diagonal_hamiltonian = c
            self._optimum = np.max(c).real
            c = sparse.csr_matrix((c.flatten(), (np.arange(self.code.d ** (self.code.n * self.N)),
                                                 np.arange(self.code.d ** (self.code.n * self.N)))),
                                  shape=(self.code.d ** (self.code.n * self.N),
                                         self.code.d ** (self.code.n * self.N)))
        else:
            # c is already the right shape, just convert it to a csr matrix
            c = sparse.csr_matrix(c)
        self._hamiltonian = c
        self._left_acting_hamiltonian = None
        self._right_acting_hamiltonian = None

    @property
    def hamiltonian(self):
        return self.energies[0] * self._hamiltonian

    @property
    def evolution_operator(self, vector_space='hilbert'):
        if vector_space != 'hilbert' and vector_space != 'liouville':
            raise Exception('Attribute vector_space must be hilbert or liouville')
        if vector_space == 'liouville':
            if self._left_acting_hamiltonian is None:
                self._left_acting_hamiltonian = sparse.kron(sparse.identity(self._hamiltonian.shape[0]),
                                                            self._hamiltonian)
                self._right_acting_hamiltonian = sparse.kron(self._hamiltonian.T,
                                                             sparse.identity(self._hamiltonian.shape[0]))

            return -1j * self.energies[0] * self._left_acting_hamiltonian + 1j * self.energies[0] * \
                   self._right_acting_hamiltonian
        else:
            return -1j * self.hamiltonian

    @property
    def optimum(self):
        if self._is_diagonal:
            return self.energies[0] * self._optimum
        else:
            raise NotImplementedError('Optimum unknown for non-diagonal Hamiltonians')

    def evolve(self, state: State, time):
        if state.is_ket:
            if self._is_diagonal:
                return State(np.exp(-1j * time * self._diagonal_hamiltonian) * state, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)
            else:
                return State(expm_multiply(-1j * time * self.hamiltonian, state), is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)
        else:
            if self._is_diagonal:
                return State(np.exp(-1j * time * self._diagonal_hamiltonian) * state * np.exp(
                    1j * time * self._diagonal_hamiltonian).T, is_ket=state.is_ket, IS_subspace=state.IS_subspace,
                             code=state.code)
            else:
                temp = expm(-1j * time * self.hamiltonian)
                return State(temp @ state @ temp.conj().T, is_ket=state.is_ket, IS_subspace=state.IS_subspace,
                             code=state.code)

    def left_multiply(self, state: State):
        if self._is_diagonal:
            return State(self._diagonal_hamiltonian * state, is_ket=state.is_ket, IS_subspace=state.IS_subspace,
                         code=state.code)
        else:
            return State(self.hamiltonian @ state, is_ket=state.is_ket, IS_subspace=state.IS_subspace,
                         code=state.code)

    def right_multiply(self, state: State):
        # Already real, so you don't need to conjugate
        if state.is_ket:
            if self._is_diagonal:
                return State(state.conj().T * self._diagonal_hamiltonian.T, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)
            else:
                return State((state @ self.hamiltonian.T).conj().T, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)
        else:
            if self._is_diagonal:
                # Density matrices are already Hermitian, so you don't need to dagger
                return State(state * self._diagonal_hamiltonian.T, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)
            else:
                return State(state @ self.hamiltonian.T, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)

    def cost_function(self, state: State, hamiltonian=None):
        # Need to project into the IS subspace
        # Returns <s|C|s>
        if hamiltonian is None:
            if self._is_diagonal:
                hamiltonian = self._diagonal_hamiltonian
            else:
                hamiltonian = self.hamiltonian
        if state.is_ket:
            if self._is_diagonal:
                return np.real(np.vdot(state, hamiltonian * state))
            else:
                return np.real(np.vdot(state, hamiltonian @ state))
        else:
            # Density matrix
            if self._is_diagonal:
                return np.real(np.squeeze(tools.trace(hamiltonian * state)))
            else:
                return np.real(np.squeeze(tools.trace(hamiltonian @ state)))


class HamiltonianMIS(object):
    def __init__(self, G: Graph, energies=None, code=None, IS_subspace=False):
        r"""
        Generate a vector corresponding to the diagonal of the MIS Hamiltonian.
        """
        if energies is None and not IS_subspace:
            energies = [1, 1]
        elif energies is None and IS_subspace:
            energies = [1]
        if code is None:
            code = qubit
        self.code = code
        self.graph = G
        self.N = self.graph.n
        self.energies = energies
        self.IS_subspace = IS_subspace
        self.optimization = 'max'
        if not self.IS_subspace:
            # Store node and edge terms separately so the Hamiltonian can be dynamically updated when energies
            # are changed

            if tools.is_diagonal(self.code.Q):
                self._hamiltonian_edge_terms = np.zeros([1, (self.code.d ** self.code.n) ** self.N])
                self._hamiltonian_node_terms = np.zeros([1, (self.code.d ** self.code.n) ** self.N])
                self._is_diagonal = True

                Q = np.expand_dims(np.diagonal(self.code.Q), axis=0)

                def my_eye(n):
                    return np.ones(np.asarray(self.code.d ** self.code.n) ** n)
            else:
                # TODO: generate a sparse matrix instead
                self._hamiltonian_edge_terms = np.zeros([(self.code.d ** self.code.n) ** self.N,
                                                         (self.code.d ** self.code.n) ** self.N])
                self._hamiltonian_node_terms = np.zeros([(self.code.d ** self.code.n) ** self.N,
                                                         (self.code.d ** self.code.n) ** self.N])

                Q = np.expand_dims(np.diagonal(qubit.Q), axis=0)

                def my_eye(n):
                    return np.ones(np.asarray(qubit.d ** qubit.n) ** n)

                self._optimum_edge_terms = np.zeros([(qubit.d ** qubit.n) ** self.N,
                                                     (qubit.d ** qubit.n) ** self.N])
                self._optimum_node_terms = np.zeros([(qubit.d ** qubit.n) ** self.N,
                                                     (qubit.d ** qubit.n) ** self.N])

                for i, j in G.graph.edges:
                    if j < i:
                        i, j = j, i
                    self._optimum_edge_terms = self._optimum_edge_terms + G.graph.edges[(i, j)]['weight'] * \
                                               tools.tensor_product(
                                                   [my_eye(i), Q, my_eye(j - i - 1), Q, my_eye(self.N - j - 1)])

                for i in G.graph.nodes:
                    self._optimum_node_terms = self._optimum_node_terms + G.graph.nodes[i]['weight'] * \
                                               tools.tensor_product([my_eye(i), Q, my_eye(self.N - i - 1)])

                self._is_diagonal = False
                Q = self.code.Q

                def my_eye(n):
                    return np.identity(np.asarray(self.code.d ** self.code.n) ** n)
            for i, j in G.graph.edges:
                if j < i:
                    i, j = j, i
                self._hamiltonian_edge_terms = self._hamiltonian_edge_terms + G.graph.edges[(i, j)]['weight'] * \
                                               tools.tensor_product(
                                                   [my_eye(i), Q, my_eye(j - i - 1), Q, my_eye(self.N - j - 1)])
            for i in G.graph.nodes:
                self._hamiltonian_node_terms = self._hamiltonian_node_terms + G.graph.nodes[i]['weight'] * \
                                               tools.tensor_product([my_eye(i), Q, my_eye(self.N - i - 1)])
            self._hamiltonian_node_terms = self._hamiltonian_node_terms.T
            self._hamiltonian_edge_terms = self._hamiltonian_edge_terms.T
            if self._is_diagonal:
                self._optimum_edge_terms = self._hamiltonian_edge_terms
                self._optimum_node_terms = self._hamiltonian_node_terms
                self._diagonal_hamiltonian_edge_terms = self._hamiltonian_edge_terms.copy()
                self._diagonal_hamiltonian_node_terms = self._hamiltonian_node_terms.copy()
                self._hamiltonian_node_terms = sparse.csr_matrix(
                    (self._hamiltonian_node_terms.flatten(), (np.arange(self.code.d ** (self.code.n * self.N)),
                                                              np.arange(self.code.d ** (self.code.n * self.N)))),
                    shape=(self.code.d ** (self.code.n * self.N),
                           self.code.d ** (self.code.n * self.N)))
                self._hamiltonian_edge_terms = sparse.csr_matrix(
                    (self._hamiltonian_edge_terms.flatten(), (np.arange(self.code.d ** (self.code.n * self.N)),
                                                              np.arange(self.code.d ** (self.code.n * self.N)))),
                    shape=(self.code.d ** (self.code.n * self.N),
                           self.code.d ** (self.code.n * self.N)))
                # TODO: what happens to _optimum_node_terms if not _is_diagonal
            else:
                self._diagonal_hamiltonian_edge_terms = self._hamiltonian_edge_terms.copy()
                self._diagonal_hamiltonian_node_terms = self._hamiltonian_node_terms.copy()
                self._hamiltonian_edge_terms = sparse.csr_matrix(self._hamiltonian_edge_terms)
                self._hamiltonian_node_terms = sparse.csr_matrix(self._hamiltonian_node_terms)
            self._left_acting_hamiltonian_edge_terms = sparse.kron(sparse.identity(
                self._hamiltonian_node_terms.shape[0]), self._hamiltonian_edge_terms)
            self._right_acting_hamiltonian_edge_terms = sparse.kron(
                self._hamiltonian_edge_terms.T, sparse.identity(self._hamiltonian_edge_terms.shape[0]))

        else:
            self._is_diagonal = True
            if not (self.code == qubit or self.code == rydberg):
                raise NotImplementedError("IS subspace only implemented for qubit and Rydberg codes.")
            # Don't generate anything that depends on the entire Hilbert space as to save space

            # These are your independent sets of the original graphs, ordered by node and size
            C = np.asarray([[self.graph.independent_sets[i][1] for i in self.graph.independent_sets]],
                           dtype=np.complex128).T

            if self.code == qubit:
                self._hamiltonian_node_terms = C
            # Otherwise, we need to include the possibility that we are in one of many ground space states
            elif self.code == rydberg:
                # Count the number of elements in the ground space and map to their representation in ternary
                # Determine how large to make the array
                independent_sets, nary_to_index, num_IS = self.graph.independent_sets_code(self.code)
                # Generate Hamiltonian from independent sets
                C = np.zeros((num_IS, 1), dtype=np.complex128)
                for k in independent_sets:
                    C[k, 0] = independent_sets[k][1]
            self._diagonal_hamiltonian_node_terms = C
            C = C.flatten()

            self._hamiltonian_node_terms = sparse.csr_matrix((
                C, (np.arange(len(C)), np.arange(len(C)))), shape=(len(C), len(C)))

        self._left_acting_hamiltonian_node_terms = sparse.kron(sparse.identity(
            self._hamiltonian_node_terms.shape[0]), self._hamiltonian_node_terms)
        self._right_acting_hamiltonian_node_terms = sparse.kron(
            self._hamiltonian_node_terms.T, sparse.identity(self._hamiltonian_node_terms.shape[0]))

    @property
    def hamiltonian(self):
        if not self.IS_subspace:
            return self.energies[0] * self._hamiltonian_node_terms - self.energies[1] * self._hamiltonian_edge_terms
        else:
            return self.energies[0] * self._hamiltonian_node_terms

    @property
    def evolution_operator(self, vector_space='hilbert'):
        if vector_space != 'hilbert' and vector_space != 'liouville':
            raise Exception('Attribute vector_space must be hilbert or liouville')
        if vector_space == 'liouville':
            if self._left_acting_hamiltonian_node_terms is None and not self.IS_subspace:
                self._left_acting_hamiltonian_edge_terms = sparse.kron(sparse.identity(
                    self._hamiltonian_node_terms.shape[0]), self._hamiltonian_edge_terms)
                self._right_acting_hamiltonian_edge_terms = sparse.kron(
                    self._hamiltonian_edge_terms.T, sparse.identity(self._hamiltonian_edge_terms.shape[0]))
                self._left_acting_hamiltonian_node_terms = sparse.kron(sparse.identity(
                    self._hamiltonian_node_terms.shape[0]), self._hamiltonian_node_terms)
                self._right_acting_hamiltonian_node_terms = sparse.kron(
                    self._hamiltonian_node_terms.T, sparse.identity(self._hamiltonian_node_terms.shape[0]))
            elif self._left_acting_hamiltonian_node_terms is None and self.IS_subspace:
                self._left_acting_hamiltonian_node_terms = sparse.kron(sparse.identity(
                    self._hamiltonian_node_terms.shape[0]), self._hamiltonian_node_terms)
                self._right_acting_hamiltonian_node_terms = sparse.kron(
                    self._hamiltonian_node_terms.T, sparse.identity(self._hamiltonian_node_terms.shape[0]))
            if not self.IS_subspace:
                return -1j * (self.energies[0] * self._left_acting_hamiltonian_node_terms - self.energies[1] *
                              self._left_acting_hamiltonian_edge_terms) + 1j * \
                       (self.energies[0] * self._right_acting_hamiltonian_node_terms - self.energies[1] *
                        self._right_acting_hamiltonian_edge_terms)
            elif self.IS_subspace:
                return -1j * (self.energies[0] * self._left_acting_hamiltonian_node_terms) + 1j * \
                       (self.energies[0] * self._right_acting_hamiltonian_node_terms)
        else:
            return -1j * self.hamiltonian

    @property
    def _diagonal_hamiltonian(self):
        if not self.IS_subspace:
            return self.energies[0] * self._diagonal_hamiltonian_node_terms - self.energies[
                1] * self._diagonal_hamiltonian_edge_terms
        else:
            return self.energies[0] * self._diagonal_hamiltonian_node_terms

    @property
    def optimum(self):
        # This needs to be recomputed because the optimum depends on the energies
        # TODO: figure out how to compute if not _is_diagonal
        if self._is_diagonal:
            return np.max(
                self.energies[0] * self._optimum_node_terms - self.energies[1] * self._optimum_edge_terms).real
        else:
            raise NotImplementedError('Optimum unknown for non-diagonal Hamiltonians')

    def evolve(self, state: State, time):
        if state.is_ket:
            if self._is_diagonal:
                return State(np.exp(-1j * time * self._diagonal_hamiltonian) * state, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)
            else:
                return State(expm_multiply(-1j * time * self.hamiltonian, state), is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)
        else:
            if self._is_diagonal:
                return State(np.exp(-1j * time * self._diagonal_hamiltonian) * state * np.exp(
                    1j * time * self._diagonal_hamiltonian).T, is_ket=state.is_ket, IS_subspace=state.IS_subspace,
                             code=state.code)
            else:
                temp = expm(-1j * time * self.hamiltonian)
                return State(temp @ state @ temp.conj().T, is_ket=state.is_ket, IS_subspace=state.IS_subspace,
                             code=state.code)

    def left_multiply(self, state: State):
        if self._is_diagonal:
            return State(self._diagonal_hamiltonian * state, is_ket=state.is_ket, IS_subspace=state.IS_subspace,
                         code=state.code)
        else:
            return State(self.hamiltonian @ state, is_ket=state.is_ket, IS_subspace=state.IS_subspace,
                         code=state.code)

    def right_multiply(self, state: State):
        # Already real, so you don't need to conjugate
        if state.is_ket:
            if self._is_diagonal:
                return State(state.conj().T * self._diagonal_hamiltonian.T, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)
            else:
                return State((state @ self.hamiltonian.T).conj().T, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)
        else:
            if self._is_diagonal:
                # Density matrices are already Hermitian, so you don't need to dagger
                return State(state * self._diagonal_hamiltonian.T, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)
            else:
                return State(state @ self.hamiltonian.T, is_ket=state.is_ket,
                             IS_subspace=state.IS_subspace, code=state.code)

    def cost_function(self, state: State, hamiltonian=None):
        # Need to project into the IS subspace
        # Returns <s|C|s>
        if hamiltonian is None:
            if self._is_diagonal:
                hamiltonian = self._diagonal_hamiltonian
            else:
                hamiltonian = self.hamiltonian
        if state.is_ket:
            if self._is_diagonal:
                return np.real(np.vdot(state, hamiltonian * state))
            else:
                return np.real(np.vdot(state, hamiltonian @ state))
        else:
            # Density matrix
            if self._is_diagonal:
                return np.real(np.squeeze(tools.trace(hamiltonian * state)))
            else:
                return np.real(np.squeeze(tools.trace(hamiltonian @ state)))


class HamiltonianGlobalPauli(object):
    def __init__(self, pauli: str, code=None):
        super().__init__()
        if code is None:
            self.code = qubit
        else:
            self.code = code
        self.pauli = pauli
        if self.pauli == 'X':
            self._operator = self.code.X
        elif self.pauli == 'Y':
            self._operator = self.code.Y
        elif self.pauli == 'Z':
            self._operator = self.code.Z
        self.hamiltonian = None

    def evolve(self, state: State, alpha):
        if self.hamiltonian is None:
            """Initialize the Hamiltonian only once, as it is costly."""
            # TODO: make this a sparse matrix!
            self.hamiltonian = tools.tensor_product([self._operator] * state.number_logical_qudits)
        return self.code.multiply(np.cos(alpha) * np.identity(state.dimension) - 1j * np.sin(alpha) * self.hamiltonian)

    def left_multiply(self, state: State):
        all_qubits = list(range(state.number_logical_qudits))
        return self.code.left_multiply(state, all_qubits, [self.pauli] * state.number_logical_qudits)

    def right_multiply(self, state: State):
        all_qubits = list(range(state.number_logical_qudits))
        return self.code.right_multiply(state, all_qubits, [self.pauli] * state.number_logical_qudits)


class HamiltonianBookatzPenalty(object):
    def __init__(self, code=None, energy=1):
        if code is None:
            self.code = qubit
        else:
            self.code = code
        self.projector = np.identity(self.code.d ** self.code.n) - self.code.code_space_projector
        self.energy = energy

    def evolve(self, state: State, time):
        # Term for a single qubit
        for i in range(state.number_logical_qudits):
            state = self.code.rotation(state, [i], self.energy * time, self.projector, is_idempotent=True)
        return state

    def left_multiply(self, state: State):
        out = np.zeros_like(state, dtype=np.complex128)
        for i in range(state.number_logical_qudits):
            out = out + self.code.left_multiply(state, [i], self.projector)
        return State(self.energy * out, is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code)

    def right_multiply(self, state: State):
        out = np.zeros_like(state, dtype=np.complex128)
        for i in range(state.number_logical_qudits):
            out = out + self.code.right_multiply(state, [i], self.projector)
        return State(self.energy * out, is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code)


class HamiltonianMarvianPenalty(object):
    def __init__(self, Nx, Ny):
        super().__init__()
        self.Nx = Nx
        self.Ny = Ny
        self.N = 3 * Nx * Ny
        # Generate Hamiltonian
        # Two by two geometry (can be generalized in the future)
        hp = np.zeros([2 ** self.N, 2 ** self.N])
        for i in range(int(self.Nx * self.Ny)):
            # Add gauge interactions within a single logical qubit
            hp = hp + tools.tensor_product(
                [tools.identity(i * 3), tools.Z(), tools.Z(),
                 tools.identity(self.N - i * 3 - 2)]) + tools.tensor_product(
                [tools.identity(i * 3 + 1), tools.X(), tools.X(), tools.identity(self.N - i * 3 - 3)])
        # Between rows
        for j in range(self.Ny):
            # j is the number of rows
            for k in range(self.Nx):
                # k is the number of columns
                # Need to deal with edge effects
                # Add gauge interactions within a single logical qubit
                if k != self.Nx - 1:
                    # Along the same row
                    hp = hp + tools.tensor_product(
                        [tools.identity(j * self.Nx * 3 + k * 3), tools.X(), tools.identity(2), tools.X(),
                         tools.identity(self.N - (j * self.Nx * 3 + k * 3) - 4)]) + \
                         tools.tensor_product(
                             [tools.identity(j * self.Nx * 3 + k * 3 + 2), tools.Z(), tools.identity(2), tools.Z(),
                              tools.identity(self.N - (j * self.Nx * 3 + k * 3 + 2) - 4)])
                    # Along the same column
                if j != self.Ny - 1:
                    hp = hp + tools.tensor_product(
                        [tools.identity(j * self.Nx * 3 + k * 3), tools.X(), tools.identity(3 * self.Nx - 1),
                         tools.X(),
                         tools.identity(self.N - (j * self.Nx * 3 + k * 3) - 3 * self.Nx - 1)]) + \
                         tools.tensor_product(
                             [tools.identity(j * self.Nx * 3 + k * 3 + 2), tools.Z(),
                              tools.identity(3 * self.Nx - 1),
                              tools.Z(), tools.identity(self.N - (j * self.Nx * 3 + k * 3 + 2) - 3 * self.Nx - 1)])
        self.hamiltonian = -1 * hp


class HamiltonianHeisenberg(object):
    def __init__(self, G: nx.Graph, energy=(1, 1, 0), code=None):
        if code is None:
            code = qubit
        self.code = code
        self.graph = G
        self.N = self.graph.number_of_nodes()
        self.energy = energy
        self.hamiltonian = None
        self.IS_projector = IS_projector(self.graph, self.code)

    def left_multiply(self, state: State):
        temp = np.zeros(state.shape, dtype=np.complex128)
        for edge in self.graph.edges:
            if self.energy[0] != 0:
                term = self.code.left_multiply(state, [edge[0], edge[1]], ['X', 'X'])
                temp = temp + self.energy[0] * term
            if self.energy[1] != 0:
                term = self.code.left_multiply(state, [edge[0], edge[1]], ['Y', 'Y'])
                temp = temp + self.energy[1] * term
            if self.energy[2] != 0:
                term = self.code.left_multiply(state, [edge[0], edge[1]],
                                               tools.tensor_product([self.code.U, self.code.U]))
                temp = temp + self.energy[2] * term
        return State(temp, is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code)

    def right_multiply(self, state: State):
        temp = np.zeros(state.shape, dtype=np.complex128)
        for edge in self.graph.edges:
            if self.energy[0] != 0:
                term = self.code.right_multiply(state, [edge[0], edge[1]], ['X', 'X'])
                temp = temp + self.energy[0] * term
            if self.energy[1] != 0:
                term = self.code.right_multiply(state, [edge[0], edge[1]], ['Y', 'Y'])
                temp = temp + self.energy[2] * term
            if self.energy[2] != 0:
                term = self.code.right_multiply(state, [edge[0], edge[1]],
                                                tools.tensor_product([self.code.U, self.code.U]))
                temp = temp + self.energy[2] * term
        return State(temp, is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code)

    def evolve(self, state: State, time):
        if self.hamiltonian is None:
            """Initialize the Hamiltonian."""
            # TODO: Don't generate the whole matrix then convert to a sparse matrix!
            hamiltonian = np.zeros((state.shape[0], state.shape[0]))
            for (i, j) in self.graph.edges:
                hamiltonian = hamiltonian + self.energy[0] * \
                              tools.tensor_product([tools.identity(self.code.n * i, d=self.code.d), self.code.X,
                                                    tools.identity(self.code.n * (j - i - 1), d=self.code.d),
                                                    self.code.X,
                                                    tools.identity(self.code.n * (self.N - j - 1), d=self.code.d)])
                hamiltonian = hamiltonian + self.energy[1] * \
                              tools.tensor_product([tools.identity(self.code.n * i, d=self.code.d), self.code.Y,
                                                    tools.identity(self.code.n * (j - i - 1), d=self.code.d),
                                                    self.code.Y,
                                                    tools.identity(self.code.n * (self.N - j - 1), d=self.code.d)])
                hamiltonian = hamiltonian + self.energy[2] * \
                              tools.tensor_product([tools.identity(self.code.n * i, d=self.code.d), self.code.U,
                                                    tools.identity(self.code.n * (j - i - 1), d=self.code.d),
                                                    self.code.U,
                                                    tools.identity(self.code.n * (self.N - j - 1), d=self.code.d)])
            hamiltonian = sparse.csr_matrix(hamiltonian)
            self.hamiltonian = hamiltonian

        if not state.is_ket:
            return State(expm(-1j * time * self.hamiltonian) @ state @ expm(1j * time * self.hamiltonian),
                         is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code)
        if state.is_ket:
            return State(expm_multiply(-1j * time * self.hamiltonian, state), is_ket=state.is_ket,
                         IS_subspace=state.IS_subspace, code=state.code)

    def cost_function(self, state: State):
        # Need to project into the IS subspace
        # Returns <s|C|s>
        if state.is_ket:
            return np.real(np.vdot(state, self.IS_projector * self.hamiltonian * state))
        else:
            # Density matrix
            return np.real(np.squeeze(tools.trace(self.IS_projector * self.hamiltonian * state)))


class HamiltonianEnergyShift(object):
    def __init__(self, index: int = 1, energies=None, code=None, IS_subspace=False, graph=None):
        """Default is that the first element in transition is the higher energy s."""
        if energies is None:
            energies = [1]
        self.index = index
        self.energies = energies
        if code is None:
            code = qubit
        self.code = code
        if not self.code.logical_code:
            self._operator = np.zeros((self.code.d, self.code.d))
            self._operator[self.index, self.index] = 1
        else:
            if self.index != 0 and self.index != 1:
                raise Exception('Logical codes are qubits, so index must be 0 or 1.')
            if self.index == 0:
                self._operator = self.code.Q
            elif self.index == 1:
                self._operator = self.code.P
        self.IS_subspace = IS_subspace
        if self.IS_subspace:
            # Generate sparse mixing Hamiltonian
            assert graph is not None
            assert isinstance(graph, Graph)
            if code is not qubit:
                IS, nary_to_index, num_IS = graph.independent_sets_code(self.code)
            else:
                # We have already solved for this information
                IS, nary_to_index, num_IS = graph.independent_sets, graph.binary_to_index, graph.num_independent_sets
            self._diagonal_hamiltonian = np.zeros((num_IS, 1), dtype=np.complex128)
            for k in IS:
                self._diagonal_hamiltonian[k, 0] = np.sum(IS[k][2] == self.index)
            self._hamiltonian = sparse.csr_matrix(
                (self._diagonal_hamiltonian.T[0], (np.arange(len(self._diagonal_hamiltonian)),
                                                   np.arange(len(self._diagonal_hamiltonian)))))

        # TODO: define self.hamiltonian for non-IS_subspace

    @property
    def hamiltonian(self):
        return self.energies[0] * self._hamiltonian

    def left_multiply(self, state: State):
        if not self.IS_subspace:
            temp = np.zeros_like(state)
            # For each logical qubit
            state_shape = state.shape
            for i in range(state.number_logical_qudits):
                if self.code.logical_code:
                    temp = temp + self.code.left_multiply(state, [i], self._operator)
                elif not self.code.logical_code:
                    ind = self.code.d ** i
                    out = np.zeros_like(state, dtype=np.complex128)
                    if state.is_ket:
                        state = state.reshape((-1, self.code.d, ind), order='F')
                        # Note index start from the right (sN,...,s3,s2,s1)
                        out = out.reshape((-1, self.code.d, ind), order='F')
                        out[:, self.index, :] = state[:, self.index, :]
                        state = state.reshape(state_shape, order='F')
                        out = out.reshape(state_shape, order='F')
                    else:
                        out = out.reshape((-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1),
                                           self.code.d, ind), order='F')
                        state = state.reshape((-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1),
                                               self.code.d, ind), order='F')
                        out[:, self.index, :, :, :] = state[:, self.index, :, :, :]
                        state = state.reshape(state_shape, order='F')
                        out = out.reshape(state_shape, order='F')
                    temp = temp + out
            return State(self.energies[0] * temp, is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code)
        else:
            # Handle dimensions
            return State(self.energies[0] * self._diagonal_hamiltonian * state, is_ket=state.is_ket,
                         IS_subspace=state.IS_subspace,
                         code=state.code)

    def right_multiply(self, state: State):
        assert not state.is_ket, 'Right multiply functionality currently only exists for density matrices.'
        if not self.IS_subspace:
            temp = np.zeros_like(state)
            # For each physical qubit
            state_shape = state.shape
            for i in range(state.number_logical_qudits):
                if self.code.logical_code:
                    temp = temp + self.code.right_multiply(state, [i], self._operator)
                else:
                    ind = self.code.d ** i
                    out = np.zeros_like(state)
                    out = out.reshape(
                        (-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1), self.code.d, ind),
                        order='F')
                    state = state.reshape(
                        (-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1), self.code.d, ind),
                        order='F')
                    out[:, :, :, self.index, :] = state[:, :, :, self.index, :]
                    state = state.reshape(state_shape, order='F')
                    out = out.reshape(state_shape, order='F')
                    temp = temp + out
            return State(self.energies[0] * temp, is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code)
        else:
            return State(self.energies[0] * state * self._diagonal_hamiltonian.T, is_ket=state.is_ket,
                         IS_subspace=state.IS_subspace,
                         code=state.code)

    def evolve(self, state: State, time):
        r"""
        Use reshape to efficiently implement evolution under :math:`H_B=\\sum_i X_i`
        """
        if not self.IS_subspace:
            # We don't want to modify the original s
            out = state.copy()
            for i in range(state.number_logical_qudits):
                # Note that self._operator is not necessarily involutary
                out = self.code.rotation(out, [i], self.energies[0] * time, self._operator)
            return out
        else:
            # Handle dimensions
            return State(np.exp(-1j * self.energies[0] * time * self._diagonal_hamiltonian) * state,
                         is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code)
