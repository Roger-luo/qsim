import itertools

import numpy as np
import scipy.integrate
import scipy.optimize
from odeintw import odeintw

import scipy.sparse as sparse
from scipy.linalg import expm
from scipy.sparse.linalg import expm_multiply

from qsim.codes import qubit
from qsim.codes.quantum_state import State
from qsim.evolution import lindblad_operators, hamiltonian
from qsim.graph_algorithms.graph import Graph
from qsim.graph_algorithms.graph import line_graph, degree_fails_graph
from qsim.lindblad_master_equation import LindbladMasterEquation
from qsim.schrodinger_equation import SchrodingerEquation
from qsim.tools import tools


class EffectiveOperatorHamiltonian(object):
    def __init__(self, omega_g, omega_r, energies=(1,), graph: Graph = None, IS_subspace=True, code=qubit):
        # Just need to define self.hamiltonian
        assert IS_subspace
        self.energies = energies
        self.IS_subspace = IS_subspace
        self.graph = graph
        self.omega_r = omega_r
        self.omega_g = omega_g
        self.code = code
        assert self.code is qubit

        if self.IS_subspace:
            # Generate sparse mixing Hamiltonian
            assert graph is not None
            assert isinstance(graph, Graph)
            # We have already solved for this information
            IS, nary_to_index, num_IS = graph.independent_sets, graph.binary_to_index, graph.num_independent_sets
            self.transition = (0, 1)
            self._hamiltonian_rr = np.zeros((num_IS, num_IS))
            self._hamiltonian_gg = np.zeros((num_IS, num_IS))
            self._hamiltonian_cross_terms = np.zeros((num_IS, num_IS))
            for k in IS:
                self._hamiltonian_rr[k, k] = np.sum(IS[k][2] == self.transition[0])
                self._hamiltonian_gg[k, k] = np.sum(IS[k][2] == self.transition[1])
            self._csc_hamiltonian_rr = sparse.csc_matrix(self._hamiltonian_rr)
            self._csc_hamiltonian_gg = sparse.csc_matrix(self._hamiltonian_gg)
            # For each IS, look at spin flips generated by the laser
            # Over-allocate space
            rows = np.zeros(graph.n * num_IS, dtype=int)
            columns = np.zeros(graph.n * num_IS, dtype=int)
            entries = np.zeros(graph.n * num_IS, dtype=float)
            num_terms = 0
            for i in IS:
                for j in range(len(IS[i][2])):
                    if IS[i][2][j] == self.transition[1]:
                        # Flip spin at this location
                        # Get binary representation
                        temp = IS[i][2].copy()
                        temp[j] = self.transition[0]
                        flipped_temp = tools.nary_to_int(temp, base=code.d)
                        if flipped_temp in nary_to_index:
                            # This is a valid spin flip
                            rows[num_terms] = nary_to_index[flipped_temp]
                            columns[num_terms] = i
                            entries[num_terms] = 1
                            num_terms += 1
            # Cut off the excess in the arrays
            columns = columns[:2 * num_terms]
            rows = rows[:2 * num_terms]
            entries = entries[:2 * num_terms]
            # Populate the second half of the entries according to self.pauli
            columns[num_terms:2 * num_terms] = rows[:num_terms]
            rows[num_terms:2 * num_terms] = columns[:num_terms]
            entries[num_terms:2 * num_terms] = entries[:num_terms]
            # Now, construct the Hamiltonian
            self._csc_hamiltonian_cross_terms = sparse.csc_matrix((entries, (rows, columns)), shape=(num_IS, num_IS))
            try:
                self._hamiltonian_cross_terms = self._csc_hamiltonian_cross_terms.toarray()
            except MemoryError:
                self._hamiltonian_cross_terms = self._csc_hamiltonian_cross_terms

        else:
            # We are not in the IS subspace
            pass

    @property
    def hamiltonian(self):
        return self.energies[0] * (self.omega_g * self.omega_r * self._hamiltonian_cross_terms +
                                   self.omega_g ** 2 * self._csc_hamiltonian_gg +
                                   self.omega_r ** 2 * self._csc_hamiltonian_rr)

    def left_multiply(self, state: State):
        return self.hamiltonian @ state

    def right_multiply(self, state: State):
        return state @ self.hamiltonian

    def evolve(self, state: State, time):
        if state.is_ket:
            return State(expm_multiply(-1j * time * self.hamiltonian, state),
                         is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code, graph=self.graph)

        else:
            exp_hamiltonian = expm(-1j * time * self.hamiltonian)
            return State(exp_hamiltonian @ state @ exp_hamiltonian.conj().T,
                         is_ket=state.is_ket, IS_subspace=state.IS_subspace, code=state.code, graph=self.graph)


class EffectiveOperatorDissipation(lindblad_operators.LindbladJumpOperator):
    def __init__(self, omega_g, omega_r, rates=(1,), graph: Graph = None, IS_subspace=True, code=qubit):
        self.omega_g = omega_g
        self.omega_r = omega_r

        self.IS_subspace = IS_subspace
        self.transition = (0, 1)
        self.graph = graph
        # Construct jump operators
        if self.IS_subspace:
            # Generate sparse mixing Hamiltonian
            assert graph is not None
            assert isinstance(graph, Graph)
            if code is not qubit:
                IS, nary_to_index, num_IS = graph.independent_sets_code(self.code)
            else:
                # We have already solved for this information
                IS, nary_to_index, num_IS = graph.independent_sets, graph.binary_to_index, graph.num_independent_sets
            self._jump_operators_rg = []
            self._jump_operators_gg = []
            # For each atom, consider the states spontaneous emission can generate transitions between
            # Over-allocate space
            for j in range(graph.n):
                rows_rg = np.zeros(num_IS, dtype=int)
                columns_rg = np.zeros(num_IS, dtype=int)
                entries_rg = np.zeros(num_IS, dtype=int)
                rows_gg = np.zeros(num_IS, dtype=int)
                columns_gg = np.zeros(num_IS, dtype=int)
                entries_gg = np.zeros(num_IS, dtype=int)
                num_terms_gg = 0
                num_terms_rg = 0
                for i in IS:
                    if IS[i][2][j] == self.transition[0]:
                        # Flip spin at this location
                        # Get binary representation
                        temp = IS[i][2].copy()
                        temp[j] = self.transition[1]
                        flipped_temp = tools.nary_to_int(temp, base=code.d)
                        if flipped_temp in nary_to_index:
                            # This is a valid spin flip
                            rows_rg[num_terms_rg] = nary_to_index[flipped_temp]
                            columns_rg[num_terms_rg] = i
                            entries_rg[num_terms_rg] = 1
                            num_terms_rg += 1
                    elif IS[i][2][j] == self.transition[1]:
                        rows_gg[num_terms_gg] = i
                        columns_gg[num_terms_gg] = i
                        entries_gg[num_terms_gg] = 1
                        num_terms_gg += 1

                # Cut off the excess in the arrays
                columns_rg = columns_rg[:num_terms_rg]
                rows_rg = rows_rg[:num_terms_rg]
                entries_rg = entries_rg[:num_terms_rg]
                columns_gg = columns_gg[:num_terms_gg]
                rows_gg = rows_gg[:num_terms_gg]
                entries_gg = entries_gg[:num_terms_gg]
                # Now, append the jump operator
                jump_operator_rg = sparse.csc_matrix((entries_rg, (rows_rg, columns_rg)), shape=(num_IS, num_IS))
                jump_operator_gg = sparse.csc_matrix((entries_gg, (rows_gg, columns_gg)), shape=(num_IS, num_IS))

                self._jump_operators_rg.append(jump_operator_rg)
                self._jump_operators_gg.append(jump_operator_gg)
            self._jump_operators_rg = np.asarray(self._jump_operators_rg)
            self._jump_operators_gg = np.asarray(self._jump_operators_gg)
        else:
            # self._jump_operators_rg = []
            # self._jump_operators_gg = []
            op_rg = np.array([[[0, 0], [1, 0]]])
            op_gg = np.array([[[0, 0], [0, 1]]])
            self._jump_operators_rg = op_rg
            self._jump_operators_gg = op_gg

        super().__init__(None, rates=rates, graph=graph, IS_subspace=IS_subspace, code=code)

    @property
    def jump_operators(self):
        return np.sqrt(self.rates[0]) * (self.omega_g * self._jump_operators_gg +
                                         self.omega_r * self._jump_operators_rg)

    @property
    def liouville_evolution_operator(self):
        if self._evolution_operator is None and self.IS_subspace:
            num_IS = self.graph.num_independent_sets
            self._evolution_operator = sparse.csr_matrix((num_IS ** 2, num_IS ** 2))
            for jump_operator in self.jump_operators:
                # Jump operator is real, so we don't need to conjugate
                self._evolution_operator = self._evolution_operator + sparse.kron(jump_operator,
                                                                                  jump_operator) - 1 / 2 * \
                                           sparse.kron(jump_operator.T @ jump_operator, sparse.identity(num_IS)) - \
                                           1 / 2 * sparse.kron(sparse.identity(num_IS), jump_operator.T @ jump_operator)

        elif self._evolution_operator is None:
            # TODO: generate the evolution operator for non-IS subspace states
            raise NotImplementedError
        return self.rates[0] * self._evolution_operator


def Q_two_atoms(phi):
    # Get theta
    theta = np.angle(np.cos(2 * phi) / np.sqrt(1 + np.sin(2 * phi) ** 2) + 1j * np.sqrt(2) * np.sin(2 * phi) / np.sqrt(
        1 + np.sin(2 * phi) ** 2))
    Q = np.zeros((3, 3))
    Q[0, 1] = np.sin(theta / 2) ** 2 * (
                np.cos(phi) / 2 * np.cos(theta / 2) + np.sin(phi) / np.sqrt(2) * np.sin(theta / 2)) ** 2


def Q(eq: SchrodingerEquation, dissipation):
    # Diagonalize Hamiltonian
    # Compute Q matrix elements
    eigval, eigvec = eq.eig()
    q = np.zeros((len(eigval), len(eigval)))
    jump_operators = np.array(dissipation.jump_operators)
    # For each pair of eigenvectors
    for pair in itertools.product(range(eigvec.shape[0]), repeat=2):
        # Compute the rate
        if pair[0] != pair[1]:
            eigvec1 = State(tools.outer_product(eigvec[pair[0]].T, eigvec[pair[0]].T), is_ket=False, IS_subspace=True,
                            graph=graph)
            eigvec2 = State(tools.outer_product(eigvec[pair[1]].T, eigvec[pair[1]].T), is_ket=False, IS_subspace=True,
                            graph=graph)

            rates = np.sum([np.trace(eigvec2 @ jump_operators[i] @ eigvec1 @ jump_operators[i].conj().T) for i in
                            range(len(jump_operators))])
            q[pair[1], pair[0]] = rates.real ** 2
            q[pair[0], pair[0]] = q[pair[0], pair[0]] - rates.real ** 2
    return q


def hamiltonian_time_derivative_term(t, eq: LindbladMasterEquation, eigenbasis, eigenenergies):

    hammy = np.pi/2*(eq.hamiltonians[0]._hamiltonian_rr * 2*np.sin((1-t)*np.pi/2)*np.cos((1-t)*np.pi/2)-\
    eq.hamiltonians[0]._hamiltonian_gg * 2 * np.sin((1 - t) * np.pi / 2) * np.cos((1 - t)* np.pi / 2)+\
        np.cos((1-t)*np.pi)* eq.hamiltonians[0]._hamiltonian_cross_terms)
    return hammy


def compute_first_order_beta(rho, eq, theta, schedule):
    # Change the basis of the jump operators
    num = 100
    times = np.linspace(0, 1, num)
    dim = eq.hamiltonians[0].hamiltonian.shape[0]
    times = times[5:-5]
    def evolve(rho, t):
        # Generate a mapping from a time to an index
        schedule(t, 1)
        eigenenergies, eigenbasis = np.linalg.eigh(eq.hamiltonians[0].hamiltonian)
        eigenenergies = np.flip(eigenenergies)
        eigenbasis = np.flip(eigenbasis, axis=1)
        # Compute theta
        def compute_eigenenergies(t, y):
            schedule(t, 1)
            # Compute the Hamiltonian basis vectors
            eigval, eigvec = np.linalg.eigh(eq.hamiltonians[0].hamiltonian)
            return eigval
        theta = \
            scipy.integrate.solve_ivp(compute_eigenenergies, (0, t), np.zeros(dim), atol=1e-8, rtol=1e-6,
                                      method='DOP853')['y'].T[-1]
        theta = np.flip(theta)
        schedule(t, 1)

        # Generate matrix of energy denominators
        energy_denom = np.reshape(np.repeat(eigenenergies, dim), (dim, dim))
        energy_denom = energy_denom.T-energy_denom
        np.fill_diagonal(energy_denom, np.ones(dim))
        energy_denom = 1/energy_denom
        rho = rho @ (hamiltonian_time_derivative_term(t, eq, eigenbasis, eigenbasis) * energy_denom) \
              - (hamiltonian_time_derivative_term(t, eq, eigenbasis, eigenbasis) * energy_denom) @ rho
        rho = rho*np.exp(-1j*(theta))*np.exp(1j*(theta)).T
        return rho

    psi0 = np.zeros((dim, dim), dtype=np.complex128)
    psi0[-1, -1] = 1
    s = odeintw(evolve, psi0, times, full_output=True)[0][-1,:,:]
    print(s, np.linalg.eigh(s), tools.is_hermitian(s))

def compute_alpha_order(rhos, eq:LindbladMasterEquation, schedule):
    num = 100
    times = np.linspace(0, 1, num)
    dim = eq.hamiltonians[0].hamiltonian.shape[0]
    def evolve(t):
        # Generate a mapping from a time to an index
        def find_nearest_index(array, value):
            array = np.asarray(array)
            idx = (np.abs(array - value)).argmin()
            return idx
        index = find_nearest_index(times, t)
        schedule(t, 1)
        eigenenergies, eigenbasis = SchrodingerEquation(hamiltonians=eq.hamiltonians).eig()
        eigenbasis = eigenbasis.T


        ops = []
        for op in eq.jump_operators[0].jump_operators:
            ops.append(eigenbasis.conj().T @ op @ eigenbasis)

        temp = np.zeros((dim, dim))
        for op in ops:
            temp = temp + op @ rhos[index] @ op.conj().T - 1/2*(op.conj().T @ op @ rhos[index] +
                                                              rhos[index] @ op.conj().T @ op)
        return np.diag(np.multiply(temp, np.identity(dim)))

    s = scipy.integrate.quad_vec(evolve, 0, 1, epsrel=1e-5)[0]
    return s


def compute_first_alpha_order(eq:LindbladMasterEquation, schedule, degenerate=False):
    """Use quad integrator, and only integrate the function at set times. Solve for the lowest eigenvalue only.
    """
    def evolve(t):
        # Generate a mapping from a time to an index
        schedule(t, 1)
        ground_energy, ground_state = SchrodingerEquation(hamiltonians=eq.hamiltonians).ground_state()
        overlap = 0
        if not degenerate:
            for op in eq.jump_operators[0].jump_operators:
                overlap = overlap + (np.abs(ground_state.conj().T@op@ground_state)**2)[0,0]-(ground_state.conj().T @op.conj().T @op @ ground_state)[0,0]
        else:
            raise NotImplementedError
        return overlap.real
    return scipy.integrate.quad(evolve, 0, 1, epsrel=1e-7, epsabs=1e-7)[0]


def compute_correction_specific_beta(eq:LindbladMasterEquation, schedule):
    """Use quad integrator, and only integrate the function at set times. Solve for the lowest eigenvalue only.
    """
    def energy_difference(t):
        schedule(t, 1)
        eigvals, eigvecs = SchrodingerEquation(hamiltonians=eq.hamiltonians).eig()
        return eigvals[-1]-eigvals[0]

    def integrated_phase_factor(t):
        return scipy.integrate.quad(energy_difference, 0, t, epsrel=1e-7, epsabs=1e-7)[0]

    def evolve(t, part='real'):
        # Generate a mapping from a time to an index
        dt=.001
        phase = integrated_phase_factor(t)
        schedule(t, 1)
        eigvals, eigvecs = SchrodingerEquation(hamiltonians=eq.hamiltonians).eig()
        schedule(t-dt, 1)
        eigvals_past, eigvecs_past = SchrodingerEquation(hamiltonians=eq.hamiltonians).eig()
        # ensure that the first eigenvalue is positive
        if eigvecs[0][0]<=0:
            eigvecs[0] = eigvecs[0]*-1

        if eigvecs_past[0][0]<=0:
            eigvecs_past[0] = eigvecs_past[0]*-1

        if eigvecs[-1][0]<=0:
            eigvecs[-1] = eigvecs[-1]*-1

        if eigvecs_past[-1][0]<=0:
            eigvecs_past[-1] = eigvecs_past[-1]*-1
        #print(eigvecs[0]-eigvecs_past[0])
        #print(t, np.vdot(eigvecs[-1], (eigvecs[0]-eigvecs_past[0])/dt))
        if part == 'real':
            res = (np.vdot(eigvecs[-1], (eigvecs[0]-eigvecs_past[0])/dt)*np.exp(-1j*phase)).real
            if res < 0:
                print('warning: real part is negative', t, res)
                #return 0
            return res
        else:
            res = (np.vdot(eigvecs[-1], (eigvecs[0]-eigvecs_past[0])/dt)*np.exp(-1j*phase)).imag
            if res > 0:
                print('warning: complex part is positive', t, res)
                #return 0
            return res

    real = scipy.integrate.quad(lambda t: evolve(t, part='real'), 0.0, 1)[0]
    complex = scipy.integrate.quad(lambda t: evolve(t, part='complex'), 0.0, 1)[0]
    print(real + 1j*complex)
    return real**2 + complex**2


def compute_first_beta_order(eq:LindbladMasterEquation, schedule):
    dt = .001
    def energy_difference(t):
        schedule(t, 1)
        eigvals, eigvecs = SchrodingerEquation(hamiltonians=eq.hamiltonians).eig()
        return eigvals[-1] - eigvals[0]

    def integrated_phase_factor(t):
        return scipy.integrate.quad(energy_difference, 0, t, epsrel=1e-7, epsabs=1e-7)[0]

    phase = integrated_phase_factor(1)
    # Compute matrix element at the very beginning and end
    schedule(1-dt, 1)
    eigvals, eigvecs = SchrodingerEquation(hamiltonians=eq.hamiltonians).eig()
    schedule(1 - 2*dt, 1)
    eigvals_past, eigvecs_past = SchrodingerEquation(hamiltonians=eq.hamiltonians).eig()
    # ensure that the first eigenvalue is positive
    if eigvecs[0][0] <= 0:
        eigvecs[0] = eigvecs[0] * -1

    if eigvecs_past[0][0] <= 0:
        eigvecs_past[0] = eigvecs_past[0] * -1

    if eigvecs[-1][0] <= 0:
        eigvecs[-1] = eigvecs[-1] * -1

    if eigvecs_past[-1][0] <= 0:
        eigvecs_past[-1] = eigvecs_past[-1] * -1

    res_end = (np.vdot(eigvecs[-1], (eigvecs[0] - eigvecs_past[0]) / dt)/(eigvals[0]-eigvals[-1]))
    schedule(2*dt, 1)
    eigvals, eigvecs = SchrodingerEquation(hamiltonians=eq.hamiltonians).eig()
    schedule(dt, 1)
    eigvals_past, eigvecs_past = SchrodingerEquation(hamiltonians=eq.hamiltonians).eig()
    # ensure that the first eigenvalue is positive
    if eigvecs[0][0] <= 0:
        eigvecs[0] = eigvecs[0] * -1

    if eigvecs_past[0][0] <= 0:
        eigvecs_past[0] = eigvecs_past[0] * -1

    if eigvecs[-1][0] <= 0:
        eigvecs[-1] = eigvecs[-1] * -1

    if eigvecs_past[-1][0] <= 0:
        eigvecs_past[-1] = eigvecs_past[-1] * -1

    res_beginning = (np.vdot(eigvecs[-1], (eigvecs[0] - eigvecs_past[0]) / dt)/(eigvals[0]-eigvals[-1]))
    print(res_end**2+res_beginning**2)



def expansion(mode='reit'):
    # Find the performance vs alpha
    graph = line_graph(n=2)
    num = 100
    times = np.linspace(0, 1, 100)
    if mode == 'reit':
        laser = EffectiveOperatorHamiltonian(graph=graph, omega_r=1, omega_g=1,
                                             energies=(1,))
        dissipation = EffectiveOperatorDissipation(graph=graph, omega_r=1, omega_g=1,
                                                   rates=(1,))
        rydberg_hamiltonian_cost = hamiltonian.HamiltonianMIS(graph, IS_subspace=True, code=qubit)

        def schedule_EIT(t, tf):
            phi = (tf - t) / tf * np.pi / 2
            laser.omega_g = np.cos(phi)
            laser.omega_r = np.sin(phi)
            dissipation.omega_g = np.cos(phi)
            dissipation.omega_r = np.sin(phi)

        """def compute_eigenenergies(t, y):
            schedule_EIT(t, 1)
            # Compute the Hamiltonian basis vectors
            eq = SchrodingerEquation(hamiltonians=[laser])
            eigval, eigvec = eq.eig()
            return eigval
        """
        #theta = \
        #    scipy.integrate.solve_ivp(compute_eigenenergies, (0, 1), np.zeros(eigval.shape), atol=1e-8, rtol=1e-6,
        #                              method='DOP853', t_eval=times)['y'].T
        schedule=schedule_EIT
        eq = LindbladMasterEquation(hamiltonians=[laser], jump_operators=[dissipation])

    if mode == 'adiabatic':
        def schedule_adiabatic(t, tf):
            energy_shift.energies = (- 3 * (t / tf - 1 / 2),)
            laser.energies = (np.cos(t / tf * np.pi)*np.sin(t / tf * np.pi),)
            dissipation.rates = (np.sin(t / tf * np.pi) ** 2,)
            # Now run the standard adiabatic algorithm

        laser = EffectiveOperatorHamiltonian(graph=graph, IS_subspace=True,
                                             energies=(1,),
                                             omega_g=np.cos(np.pi / 4),
                                             omega_r=np.sin(np.pi / 4))
        energy_shift = hamiltonian.HamiltonianEnergyShift(IS_subspace=True, graph=graph,
                                                          energies=(2.5,), index=0)
        dissipation = EffectiveOperatorDissipation(graph=graph, omega_r=1, omega_g=1,
                                                   rates=(1,))
        schedule = schedule_adiabatic
        eq = LindbladMasterEquation(hamiltonians=[laser, energy_shift], jump_operators=[dissipation])

    if mode == 'hybrid':
        def schedule_hybrid(t, tf):
            phi = (tf - t) / tf * np.pi / 2
            energy_shift.energies = (- 1.35  * (t / tf - 1 / 2),)
            laser.omega_g = np.cos(phi)
            laser.omega_r = np.sin(phi)
            dissipation.omega_g = np.cos(phi)
            dissipation.omega_r = np.sin(phi)

        laser = EffectiveOperatorHamiltonian(graph=graph, IS_subspace=True,
                                             energies=(1,),
                                             omega_g=np.cos(np.pi / 4),
                                             omega_r=np.sin(np.pi / 4))
        energy_shift = hamiltonian.HamiltonianEnergyShift(IS_subspace=True, graph=graph,
                                                          energies=(2.5,), index=0)
        dissipation = EffectiveOperatorDissipation(graph=graph, omega_r=1, omega_g=1,
                                                   rates=(1,))
        schedule = schedule_hybrid
        eq = LindbladMasterEquation(hamiltonians=[laser, energy_shift], jump_operators=[dissipation])

    rho = np.zeros((5, num, graph.num_independent_sets, graph.num_independent_sets), dtype=np.complex128)
    # Allow the integrator to allocate space. First get the zeroth order solution
    psi0 = np.zeros((graph.num_independent_sets, graph.num_independent_sets))
    psi0[0, 0] = 1
    # Convert results to density matrices
    for i in range(num):
        rho[0, i, :] = psi0
    # Compute orders in alpha
    #rho[o,:] = compute_alpha_order(rho[o-1,:], eq, schedule)
    #print(rho[o,-1,0,0])
    #print(compute_first_alpha_order(eq, schedule))
    print(compute_first_beta_order(eq, schedule))

expansion(mode='adiabatic')


"""Implementation: 
Inputs: highest order, graph, various Hamiltonian/Lindblad operators 
Construct an equation for each possible order, then solve in increasing order. 
To solve for a given order, call another function.

Inputs: density operator dependencies(t) (3), graph, various Hamiltonian/Lindblad operators 
Output: the right
"""
